---
title: "Análisis datos electorales"
author: "Rafael Farias Varona (DNI: 00000000-X), Sara García Bustos (DNI: 05439198-C), Manuel Gonzales Arambúru (DNI: 00000000-X) y Miguel Salmerón Vicente (DNI: 02769472-L)"
format:
  revealjs:
    theme: [style.scss]
    embed-resources: true
    transition: slide
    title-slide-attributes: 
      data-background-image: gradiente.jpg
execute: 
  echo: true
---

```{r}
#| message: false
#| echo: false
#| include: false

rm(list = ls())
library(tidyverse)
library(ggplot2)
library(gapminder)
library(ggthemes)
library(plotly)
library(ggThemeAssist)
library(ggridges)
library(ggtext)
library(waffle)
library(glue)
library(lubridate)
library(forcats)
library(readr)
library(stringr)
library(MetBrewer)
library(mapSpain)
library(sf)
extrafont::loadfonts()
```

```{r}
#| include: false
election_data <- read_csv(file = "./data/datos_elecciones_brutos.csv")
cod_mun <- read_csv(file = "./data/cod_mun.csv")
surveys <- read_csv(file = "./data/historical_surveys.csv")
abbrev <- read_csv(file = "./data/siglas.csv")
```

------------------------------------------------------------------------

## Manipulación de los datos {.center background-image="gradiente.jpg"}

. . .

Se obtienen dos tablas: [**election_tidy**]{style="color:blue;"} y [**surveys_tidy**]{style="color:blue;"}

------------------------------------------------------------------------

```{r}
#| include: false

#se separa el código por comunidad, provincia y municipio
cod_tidy <- cod_mun |> 
  separate(col = cod_mun, 
           into = c("codigo_ccaa", "codigo_provincia", "codigo_municipio"),
           sep = "-")

abbrev_tidy <- abbrev |>
  distinct(denominacion)

#se seleccionan las siglas según las instrucciones
abbrev_tidy <- abbrev_tidy |>
  mutate(siglas = case_when(
    str_detect(denominacion, "PARTIDO SOCIALISTA") ~ "PSOE",
    str_detect(denominacion, "PARTIDO POPULAR") ~ "PP",
    str_detect(denominacion, "CIUDADANOS-PARTIDO DE LA CIUDADAN[IÍ]A") ~ "CS",
    str_detect(denominacion, "PARTIDO NACIONALISTA VASCO") ~ "EAJ-PNV",
    str_detect(denominacion, "BLOQUE NACIONALISTA GALEGO") ~ "BNG",
    str_detect(denominacion, "\\b(UNIDAS PODEMOS|UNIDOS PODEMOS|PODEMOS|IU|PODEM|EZKER BATUA)\\b") ~ "PODEMOS",
   str_detect(denominacion, "ESQUERRA REPUBLICANA DE CATALUNYA") ~ "ERC",
   str_detect(denominacion, "EUSKAL HERRIA BILDU|SORTU|EUSKO ALKARTASUNA|ARALAR|ALTERNATIBA") ~ "EH-BILDU",
   str_detect(denominacion, "VOX") ~ "VOX",
   TRUE ~ "OTROS"
   ))

cols_election <- names(election_data)[str_detect(names(election_data), 
                                                 pattern = "[A-Z]")]
```

::: {.callout-note title="Generación election_tidy"}
Se separó la información por comunidad autónoma, provincia y municipio, y se extrajeron las abreviaturas de los partidos de interés.
:::

. . .

```{r}
#| include: false

#se convierte en tidydata
election_tidy <- election_data |> 
  pivot_longer(cols = all_of(cols_election),  names_to = "partido", 
               values_to = "votos",  values_drop_na = TRUE)

#se incorpora una columna con las siglas de los partidos políticos
election_tidy <- election_tidy |> 
  inner_join(abbrev_tidy, by = c("partido" = "denominacion")) |> 
  relocate(siglas, .after = partido) |> 
  inner_join(cod_tidy, 
             by =  c("codigo_ccaa", "codigo_provincia", "codigo_municipio")) |> 
  relocate(municipio, .after = codigo_municipio)

#se crea una columna con la fecha y se eliminan aquellas columnas que no interesan.
election_tidy <- election_tidy |> 
  mutate(fecha = paste0(mes, "-", anno)) |> 
  relocate(fecha, .after = mes) |> 
  select(-tipo_eleccion, -vuelta, - codigo_distrito_electoral)

```

```{r, echo=FALSE}
print(election_tidy, n = 4)
```

------------------------------------------------------------------------

::: {.callout-note title="Generación surveys_tidy"}
Basándonos en las siglas de los partidos que nos interesan, filtramos según los criterios establecidos.
:::

. . .

```{r}
#| include: false
cols_surveys <- names(surveys)[str_detect(names(surveys), pattern = "[A-Z]")]

siglas_interes <- c("PSOE", "PP", "EAJ-PNV", "BNG", "PODEMOS", "ERC", "EH-BILDU", "VOX","CS")

surveys_tidy <- surveys |> 
  pivot_longer(cols = all_of(cols_surveys), names_to = "siglas", 
               values_to = "votos", values_drop_na = TRUE)

#filtrar los datos según las instrucciones
surveys_tidy <- surveys_tidy |> 
  filter(year(date_elec) >= 2008) |> 
  filter(!exit_poll == TRUE) |> 
  filter(!size < 500) |> 
  filter(!field_date_to - field_date_from <= 1) |> 
  mutate(siglas = if_else(siglas %in% siglas_interes, siglas, "OTROS")) |> 
  select(-type_survey)

```

```{r, echo=FALSE}
print(surveys_tidy,n = 4)
```

------------------------------------------------------------------------

## ¿Qué partido fue el ganador en los municipios con más de 100.000 habitantes en cada elección? {.center background-image="gradiente.jpg"}

------------------------------------------------------------------------

```{r,include=TRUE}
#| code-fold: true
municipio <- election_tidy |> 
  filter(censo >= 100000) |> 
  group_by(municipio, anno, mes) |> 
  slice_max(votos, with_ties = FALSE)

```

```{r}
#| include: false
#creamos la paleta de colores para cada partido
colores_partidos <- c("#d80000","#3399FF","#6fab58","#77b4de","#6D50B3","#f3c54b","#00d0b6","#74cb4c","#FF5824","#a9a9a9","white")
colores_df <- data.frame( siglas = c(siglas_interes, "OTROS",NA), 
                          color = colores_partidos)

#se incorpora esa información a la nueva tabla
municipio <- municipio |> 
  left_join(colores_df, by = "siglas")

#se crea el tema para las gráficas
theme_gg <- theme_minimal(base_size = 14, base_family = "Times New Roman") +
  theme(
    axis.text = element_text(family = "Times New Roman", face = "bold"),
    axis.text.x = element_text(angle = 90, hjust = 1, size = 14,face = "bold"),
    axis.title = element_text(size = 15,face = "bold"),
    axis.text.y = element_text(size = 14,face = "bold"),
    legend.position = "right",
    plot.title = element_text(face = "bold"),
    plot.subtitle = element_text(size = 9),
    legend.title = element_text(size = 15),
    legend.text = element_text(size = 13),
    panel.border = element_blank(), 
    axis.line = element_line(), 
    panel.grid.major = element_blank(),
    panel.grid.minor = element_blank())

#variación del tema
theme_gg_2 <- theme_minimal(base_size = 14, base_family = "Times New Roman") +
  theme(
    axis.text = element_text(family = "Times New Roman", face = "bold"),
    axis.text.x = element_text(size = 14,face = "bold"),
    axis.title = element_text(size = 15,face = "bold"),
    axis.text.y = element_text(size = 14,face = "bold"),
    legend.position = "right",
    plot.title = element_text(face = "bold"),
    plot.subtitle = element_text(size = 9),
    legend.title = element_text(size = 15),
    legend.text = element_text(size = 13),
    panel.border = element_blank(), 
    axis.line = element_line(), 
    panel.grid.major = element_blank(),
    panel.grid.minor = element_blank())
```

```{r, echo=FALSE, include=FALSE}
# Definir la función para generar el gráfico
representar_elecciones <- function(a, m) {
  # Filtrar los datos para la elección específica
  datos <- municipio |> 
    filter(anno == a & mes == m)
  
  print(datos)
  # Crear el gráfico con ggplot2
  p <- ggplot(datos, aes(x = municipio, y = votos, fill = siglas)) +
    geom_bar(stat = "identity", 
             position = "dodge") +
    scale_y_continuous(labels = scales::comma_format()) +
    scale_fill_manual(values = setNames(colores_partidos, 
                                        c(siglas_interes, "OTROS"))) +
    labs(x = "Municipio",
         y = "Votos",
         fill = "Partido Político") +
    theme_gg
  
  return(p)
}

# Crear gráficos para cada combinación de año y mes
grafico_2008 <- representar_elecciones(2008, "03")
grafico_2011 <- representar_elecciones(2011, "11")
grafico_2015 <- representar_elecciones(2015, "12")
grafico_2016 <- representar_elecciones(2016, "06")
grafico_2019_04 <- representar_elecciones(2019, "04")
grafico_2019_11 <- representar_elecciones(2019, "11")
```

```{r, echo=FALSE, include=FALSE}
munips <- esp_get_munic()
Box <- esp_get_can_box()
Line <- esp_get_can_provinces()

#ggplot(munips) +
#  geom_sf() +
#  geom_sf(data = Box) +
#  geom_sf(data = Line) +
#  theme_linedraw()


# Asignar colores a los municipios según el censo y las siglas
mapa_elecciones <- election_tidy |>
  mutate(siglas = ifelse(!siglas %in% siglas_interes, "OTROS", siglas),
         color = ifelse(censo >= 100000, colores_df$color[match(siglas, colores_df$siglas)], "white"))

# Continuar con el resto del código
mapa_elecciones <- mapa_elecciones |>   
  mutate(periodo_electoral = case_when(fecha == "03-2008" ~ "Marzo 2008",
                                       fecha == "11-2011" ~ "Noviembre 2011",
                                       fecha == "12-2015" ~ "Diciembre 2015", 
                                       fecha == "06-2016" ~ "Junio 2016", 
                                       fecha == "04-2019" ~ "Abril 2019", 
                                       fecha == "11-2019" ~ "Noviembre 2019")) |> 
  summarise(votos = max(votos), .by = c("periodo_electoral", "codigo_municipio", "codigo_provincia")) |> 
  left_join(election_tidy |> 
              mutate(periodo_electoral = case_when(fecha == "03-2008" ~ "Marzo 2008",
                                                   fecha == "11-2011" ~ "Noviembre 2011",
                                                   fecha == "12-2015" ~ "Diciembre 2015", 
                                                   fecha == "06-2016" ~ "Junio 2016", 
                                                   fecha == "04-2019" ~ "Abril 2019", 
                                                   fecha == "11-2019" ~ "Noviembre 2019"),
                     siglas = ifelse(!siglas %in% siglas_interes, "OTROS", siglas),
                     color = ifelse(censo >= 100000, colores_df$color[match(siglas, colores_df$siglas)], "white")) |> 
              select("periodo_electoral", "codigo_municipio", "codigo_provincia", "votos", "siglas", "color"),
            by = c("periodo_electoral", "codigo_municipio", "codigo_provincia", "votos")) |> 
  right_join(munips, by = c("codigo_provincia" = "cpro", "codigo_municipio" = "cmun"))
  
```

. . . 

Partido político vencedor en las elecciones de Marzo 2008 por municipio

```{r, echo=FALSE}
#| fig-align: center
#| fig-height: 8
#| fig-width: 12
#| layout-ncol: 2
#| column: page
#| out-width: 100%
#| out-height: 100%

grafico_2008

ggplot(mapa_elecciones |> filter(periodo_electoral == "Marzo 2008")) +
  geom_sf(aes(geometry = geometry, 
              fill = color)) +
  geom_sf(data = Box) +
  geom_sf(data = Line) +
  theme_gg_2 +
  scale_fill_identity(guide = "legend", 
                      labels = setNames(colores_df$siglas, colores_df$color)) +
  labs(fill = "Partido Político")
```

------------------------------------------------------------------------

Partido político vencedor en las elecciones de Noviembre 2011 por municipio

```{r, echo=FALSE}
#| fig-align: center
#| fig-height: 8
#| fig-width: 12
#| layout-ncol: 2
#| column: page
#| out-width: 100%
#| out-height: 100%

grafico_2011

ggplot(mapa_elecciones |> filter(periodo_electoral == "Noviembre 2011")) +
  geom_sf(aes(geometry = geometry, 
              fill = color)) +
  geom_sf(data = Box) +
  geom_sf(data = Line) +
  theme_gg_2 +
  scale_fill_identity(guide = "legend", 
                      labels = setNames(colores_df$siglas, colores_df$color)) +
  labs(fill = "Partido Político")

```

------------------------------------------------------------------------

Partido político vencedor en las elecciones de Diciembre 2015 por municipio

```{r, echo=FALSE}
#| fig-align: center
#| fig-height: 8
#| fig-width: 12
#| layout-ncol: 2
#| column: page
#| out-width: 100%
#| out-height: 100%

grafico_2015

ggplot(mapa_elecciones |> filter(periodo_electoral == "Diciembre 2015")) +
  geom_sf(aes(geometry = geometry, 
              fill = color)) +
  geom_sf(data = Box) +
  geom_sf(data = Line) +
  theme_gg_2 +
  scale_fill_identity(guide = "legend", 
                      labels = setNames(colores_df$siglas, colores_df$color)) +
  labs(fill = "Partido Político")

```

------------------------------------------------------------------------

Partido político vencedor en las elecciones de Junio 2016 por municipio

```{r, echo=FALSE}
#| fig-align: center
#| fig-height: 8
#| fig-width: 12
#| layout-ncol: 2
#| column: page
#| out-width: 100%
#| out-height: 100%

grafico_2016

ggplot(mapa_elecciones |> filter(periodo_electoral == "Junio 2016")) +
  geom_sf(aes(geometry = geometry, 
              fill = color)) +
  geom_sf(data = Box) +
  geom_sf(data = Line) +
  theme_gg_2 +
  scale_fill_identity(guide = "legend", 
                      labels = setNames(colores_df$siglas, colores_df$color)) +
  labs(fill = "Partido Político")

```

------------------------------------------------------------------------

Partido político vencedor en las elecciones de Abril 2019 por municipio

```{r, echo=FALSE}
#| fig-align: center
#| fig-height: 8
#| fig-width: 12
#| layout-ncol: 2
#| column: page
#| out-width: 100%
#| out-height: 100%

grafico_2019_04

ggplot(mapa_elecciones |> filter(periodo_electoral == "Abril 2019")) +
  geom_sf(aes(geometry = geometry, 
              fill = color)) +
  geom_sf(data = Box) +
  geom_sf(data = Line) +
  theme_gg_2 +
  scale_fill_identity(guide = "legend", 
                      labels = setNames(colores_df$siglas, colores_df$color)) +
  labs(fill = "Partido Político")


```

------------------------------------------------------------------------

Partido político vencedor en las elecciones de Noviembre 2019 por municipio

```{r, echo=FALSE}
#| fig-align: center
#| fig-height: 8
#| fig-width: 12
#| layout-ncol: 2
#| column: page
#| out-width: 100%
#| out-height: 100%

grafico_2019_11

ggplot(mapa_elecciones |> filter(periodo_electoral == "Noviembre 2019")) +
  geom_sf(aes(geometry = geometry, 
              fill = color)) +
  geom_sf(data = Box) +
  geom_sf(data = Line) +
  theme_gg_2 +
  scale_fill_identity(guide = "legend", 
                      labels = setNames(colores_df$siglas, colores_df$color)) +
  labs(fill = "Partido Político")

```

## ¿Qué partido fue el segundo cuando el primero fue el PSOE? ¿Y cuando el primero fue el PP? {.center background-image="gradiente.jpg"}

------------------------------------------------------------------------

Si quedo primero en las elecciones el [**PSOE**]{style="color:red;"}

::: fragment
-   Creamos un resumen de la suma de los votos por partido
-   Ordenamos los partidos en función de su posición en las elecciones.
:::

::: fragment
-   Extraemos las fechas en las que el PSOE ganó las elecciones
-   Filtramos las elecciones en las que el ganador fue el PSOE.
:::

. . .

```{r, echo=FALSE}
#Creamos un resumen de la suma de los votos por partido. Ordenamos los partidos en función de su posición en las elecciones.
election_summary <- election_tidy |>
  summarise(total_voto = sum(votos, na.rm = TRUE), .by = c(fecha, siglas)) |> 
  arrange(desc(total_voto)) |> 
  mutate(rank = row_number(), .by = fecha) |> 
  mutate(siglas = fct_reorder(siglas, rank)) |> 
  mutate(fecha = factor(fecha, levels = c("03-2008", "11-2011", "12-2015", "06-2016", "04-2019", "11-2019")))

#Extraemos las fechas en las que el PSOE ganó las elecciones
fecha_PSOE <- election_summary |> 
  filter(rank == 1 & siglas == "PSOE") |> 
  pull(fecha)

#Filtramos las elecciones en las que el ganador fue el PSOE.
election_PSOE <- election_summary |> 
  filter(fecha %in% fecha_PSOE)
```

```{r, echo= FALSE}
#| fig-align: center
#| fig-height: 4

ggplot(data = election_PSOE, aes(x = fecha, y = total_voto, fill = fct_reorder(siglas, rank, .fun = "max"), alpha = if_else(rank == 2, "Si", "No"))) +
  geom_col(position = "dodge2") +
  scale_fill_manual(
    values = setNames(colores_partidos, c(siglas_interes, "OTROS"))) +
  scale_alpha_manual(values = c("Si" = 1, "No" = 0.15)) +
  scale_y_continuous(
    breaks = seq(0, max(election_PSOE$total_voto), by = 1000000), 
    labels = scales::comma_format()) +
  guides(alpha = "none") +
  theme_gg +
  theme(axis.text.x = element_text(angle = 0)) +
  labs(title = "Distribución de los votos cuando el PSOE fue el primero",
       x = "Fecha", y = "Total de votos", fill = "Partido")
```

------------------------------------------------------------------------

Si quedo primero en las elecciones el [**PP**]{style="color:blue;"}

::: fragment
-   Creamos un resumen de la suma de los votos por partido
-   Ordenamos los partidos en función de su posición en las elecciones.
:::

::: fragment
-   Extraemos las fechas en las que el PP ganó las elecciones
-   Filtramos las elecciones en las que el ganador fue el PP.
:::

. . .

```{r, echo = FALSE}
#| fig-align: center
#| fig-height: 4

fecha_PP <- election_summary |> 
  filter(rank == 1 & siglas == "PP") |>  pull(fecha)

election_PP <- election_summary |> 
  filter(fecha %in% fecha_PP)

ggplot(data = election_PP, aes(x = fecha, y = total_voto, fill = fct_reorder(siglas, rank, .fun = "max"), alpha = if_else(rank == 2, "Si", "No"))) +
  geom_col(position = "dodge2") +
  scale_fill_manual(
    values = setNames(colores_partidos, c(siglas_interes, "OTROS"))) +
  scale_alpha_manual(values = c("Si" = 1, "No" = 0.15)) +
  scale_y_continuous(
    breaks = seq(0, max(election_PP$total_voto), by = 1000000), 
    labels = scales::comma_format()) +
  guides(alpha = "none") +
  theme_gg +
  theme(axis.text.x = element_text(angle = 0)) +
  labs(title = "Distribución de los votos cuando el PP fue el primero",
       x = "Fecha", y = "Total de votos", fill = "Partido")
```

------------------------------------------------------------------------

## ¿Cómo calibrar el error de las encuestas? {.center background-image="gradiente.jpg"}

------------------------------------------------------------------------

```{r, echo=FALSE}
# unificar el resultado a nivel nacional de los votos con el resultado de las encuestas
elect_surv <-
  right_join(
    # primero hay que resumin la información de interés de los vosotos a nivel nacional
    election_tidy |> 
    select(anno, mes, codigo_municipio, censo, votos, partido, siglas, participacion_1, participacion_2) |> 
    summarise(censo = sum(unique(censo)),
              participacion = sum(unique(participacion_1)) + sum(unique(participacion_2)),
              .by = c("anno", "mes")) |> 
    right_join(election_tidy |> 
                 summarise(votos = sum(votos),
                 .by = c("anno", "mes", "siglas")),
               by = c("anno", "mes")) |> 
    mutate(porc_votos = (votos/participacion) * 100,
           mes = as.numeric(mes)),
    surveys_tidy |> 
      rename(intencion = votos) |> 
      # hay que unificar (sumando sus proporciones) la intención de voto de todos los partidos que se han denominado como OTROS
      mutate(intencion = sum(intencion),
              .by = c(siglas, date_elec, id_pollster, media, field_date_from, field_date_to)) |> 
      distinct() |> 
      mutate(mes = month(date_elec),
             anno = year(date_elec)),
    by = c("anno", "mes", "siglas"))
```

::: {.callout-important title="Error en encuestas"}
identificador de encuestas: anno, mes, media, field_date_from
:::

Se atiende primero a la calidad de los datos de las encuestas en cuestión a si existen en todos los periodos electorales

```{r}
elect_surv |> 
  count(media, date_elec) |> 
  arrange(date_elec, media) |> 
  pivot_wider(values_from = n, id_cols = media, names_from = date_elec)
```

------------------------------------------------------------------------

Se puede ver también que no se tiene representación de la intención de voto de todos los partidos para todos lo periodos electorales

```{r}
elect_surv |> 
  count(siglas, date_elec) |> 
  arrange(date_elec, siglas) |> 
  pivot_wider(values_from = n, id_cols = siglas, names_from = date_elec)
```

------------------------------------------------------------------------

### Análisis para la estimación de la precisión de las encuestas electorales

:::{.fragment}
Visualización de la estimación sobre la realidad

```{r, echo=FALSE}
intencion_global <-
# primero se resume la información de cada medio 
elect_surv |> 
  summarise(intencion = mean(intencion),
            .by = c("date_elec", "media", "siglas")) |> 
# después, se extrae la media global para cada periodo electoral
  summarise(intencion = mean(intencion),
            .by = c("date_elec", "siglas")) |> 
# se añade la información resumida anteriormente de los votos reales obtenidos por cada partido
  left_join(elect_surv |> 
              select(porc_votos, date_elec, siglas) |> 
              distinct(),
            by = c("date_elec", "siglas")) |> 
# los periodos en los que no se tiene porcentaje de votos registrado, se entiende que ese fue 0
  mutate(porc_votos = if_else(is.na(porc_votos), 0, porc_votos)) |> 
# por último, se calcula la diferencia entre el porcentaje estimado y el porcentaje obtenido como estimador de la precisión de las encuestas
  mutate(diferencia = intencion - porc_votos) |> 
# se modifica el nombre de cada periodo para que quede más elegante
  mutate(periodo_electoral = fct_reorder(format(date_elec, "%b %Y"), date_elec))
```

```{r, echo=FALSE}
ggplot(intencion_global) + 
  geom_col(aes(y = intencion, 
               x = siglas,
               fill = siglas),
           position = position_dodge(width = 0.9),
           width = 1,
           alpha = 0.6) + 
  scale_fill_manual(values = setNames(colores_partidos, c(siglas_interes, "OTROS"))) +
  facet_wrap(~periodo_electoral,
            scales = "free") +
  geom_col(aes(y = porc_votos, 
               x = siglas,
               fill = "grey"),
           position = position_dodge(width = 0.9),
           width = 1,
           alpha = 0.5)  +
  facet_wrap(~periodo_electoral,
            scales = "free") + 
  labs(title = "Porcentage de intención de voto estimada VS Porcentage de votos reales (sobreado)",
       fill = "Partidos",
       x = "Periodo electoral",
       y = "Porcentage")+
  theme_gg +
  theme(axis.text.x = element_blank(),
        axis.ticks.x = element_blank())
```

:::

---

:::{.fragment}
Comparación de la intención de voto global entendida como la proporción de todas las encuestas de todos los medios para cada periodo electoral.

```{r, echo=FALSE}
# se construye una representación gráfica del error para cada partdio en cada periodo

grafico1 <-
  ggplot(intencion_global) + 
           # group_by(date_elec) |> 
           # mutate(siglas = reorder_within(x = siglas, by = diferencia, within = as.character(date_elec))) |> 
           # ungroup()
  # # crear un sombreado por detrás para diferencias cada periodo
  # geom_rect(data = filter(intencion_global|> 
  #                           mutate(grupo = case_when(date_elec == "2008-03-09" ~ 1, 
  #                                                    date_elec == "2011-11-20" ~ 0,
  #                                                    date_elec == "2015-12-20" ~ 1,  
  #                                                    date_elec == "2016-06-26" ~ 0, 
  #                                                    date_elec == "2019-04-28" ~ 1, 
  #                                                    date_elec == "2019-11-10" ~ 0,
  #                                                    TRUE ~ NA)), 
  #                         grupo == 1),  # Solo fechas alternas
  #           aes(xmin = as.character(date_elec[1]),
  #               xmax = as.character(date_elec[length(intencion_global$date_elec)]),
  #               ymin = -Inf, ymax = Inf),
  #           fill = "gray90", alpha = 0.5) +
  geom_col(aes(y = diferencia, 
               x = as.character(periodo_electoral),
               fill = siglas),
           position = position_dodge(width = 0.9),
           width = 1,
           alpha = 0.7) + # , width = 200
           #scale_x_date(breaks = unique(intencion_global$date_elec)) +
  #theme(axis.text.x = element_text(angle = 90)) +
  scale_fill_manual(values = setNames(colores_partidos, c(siglas_interes, "OTROS"))) +
  facet_wrap(~periodo_electoral,
            scales = "free") + 
  labs(title = "Diferencia entre intención de voto según encuestas y porcentage de votos reales",
       fill = "Partidos",
       x = "Periodo electoral",
       y = "Diferencia") +
  theme_gg +
  theme(axis.text.x = element_blank(),
        axis.ticks.x = element_blank()) 

grafico1

#plotly::ggplotly(grafico1)
```
:::

---

::: {.fragment}
Comparación de la precisión de los medios que tienen datos para todos los periodos electorales de manera global y para cada periodo.

```{r, echo=FALSE}
# seleccionar los medios que tienen información de todos los periodos electorales
medios_completos <-
  elect_surv |> 
  count(media, date_elec) |> 
  arrange(date_elec, media) |> 
  pivot_wider(values_from = n, id_cols = media, names_from = date_elec) |> 
  drop_na() |> 
  select(media) |> 
  left_join(elect_surv, by = "media") |> 
  summarise(intencion = mean(intencion),
            .by = c("date_elec", "media", "siglas")) |> 
# se añade la información resumida anteriormente de los votos reales obtenidos por cada partido
  left_join(elect_surv |> 
              select(porc_votos, date_elec, siglas) |> 
              distinct(),
            by = c("date_elec", "siglas")) |> 
# los periodos en los que no se tiene porcentaje de votos registrado, se entiende que ese fue 0
  mutate(porc_votos = if_else(is.na(porc_votos), 0, porc_votos)) |> 
# se calcula la diferencia entre el porcentaje estimado y el porcentaje obtenido como estimador de la precisión de las encuestas
  mutate(diferencia = intencion - porc_votos) |> 
# se calcula la diferencia entre intención y porcentage de votos media de cada medio con la diferencia calculada 
  summarise(diferencia = mean(diferencia), .by = c("media", "date_elec")) |> 
# se modifica el nombre de cada periodo para que quede más elegante
  mutate(periodo_electoral = fct_reorder(format(date_elec, "%b %Y"), date_elec))
```

```{r,echo=FALSE}
# se visualiza
ggplot(medios_completos) + 
  geom_col(aes(y = diferencia, 
               x = media,
               fill = media),
           position = position_dodge(width = 0.9),
           width = 1,
           alpha = 0.6) + 
  scale_fill_met_d("Veronese") +
  facet_wrap(~periodo_electoral,
            scales = "free") +
  labs(title = "Diferencia media entre intención de voto estimada y \nporcentege de votos real de cada medio de comunicación",
       fill = "Medio",
       x = "Periodo electoral",
       y = "Diferencia media")+
  theme_gg +
  theme(axis.text.x = element_blank(),
        axis.ticks.x = element_blank())
```

:::

---

::: {.fragment}
Comparación de la precisión de las empresas encuestadoras que tienen datos para todos los periodos electorales de manera global y para cada periodo.

```{r, echo=FALSE}
# seleccionar los medios que tienen información de todos los periodos electorales
empresas_completos <-
  elect_surv |> 
  count(pollster, date_elec) |> 
  arrange(date_elec, pollster) |> 
  pivot_wider(values_from = n, id_cols = pollster, names_from = date_elec) |> 
  drop_na() |> 
  select(pollster) |> 
  left_join(elect_surv, by = "pollster") |> 
  summarise(intencion = mean(intencion),
            .by = c("date_elec", "pollster", "siglas")) |> 
# se añade la información resumida anteriormente de los votos reales obtenidos por cada partido
  left_join(elect_surv |> 
              select(porc_votos, date_elec, siglas) |> 
              distinct(),
            by = c("date_elec", "siglas")) |> 
# los periodos en los que no se tiene porcentaje de votos registrado, se entiende que ese fue 0
  mutate(porc_votos = if_else(is.na(porc_votos), 0, porc_votos)) |> 
# se calcula la diferencia entre el porcentaje estimado y el porcentaje obtenido como estimador de la precisión de las encuestas
  mutate(diferencia = intencion - porc_votos) |> 
# se calcula la diferencia entre intención y porcentage de votos media de cada medio con la diferencia calculada 
  summarise(diferencia = mean(diferencia), .by = c("pollster", "date_elec")) |> 
# se modifica el nombre de cada periodo para que quede más elegante
  mutate(periodo_electoral = fct_reorder(format(date_elec, "%b %Y"), date_elec))
```

```{r, echo=FALSE}
# se visualiza
ggplot(empresas_completos) + 
  geom_col(aes(y = diferencia, 
               x = pollster,
               fill = pollster),
           position = position_dodge(width = 0.9),
           width = 1,
           alpha = 0.6) +
  scale_fill_met_d("Veronese") +
  facet_wrap(~periodo_electoral,
            scales = "free") +
  labs(title = "Diferencia media entre intención de voto estimada y \nporcentege de votos real de cada empresa de encuestas",
       fill = "Empresa",
       x = "Periodo electoral",
       y = "Diferencia media")+
  theme_gg +
  theme(axis.text.x = element_blank(),
        axis.ticks.x = element_blank())
```

:::

---

::: {.fragment}
Visualizar si existe algún tipo de preferencia de los medios principales por algún partido en concreto.

```{r, echo=FALSE}
# seleccionar los medios que tienen información de todos los periodos electorales
medios_completos_2 <-
  elect_surv |> 
  count(media, date_elec) |> 
  arrange(date_elec, media) |> 
  pivot_wider(values_from = n, id_cols = media, names_from = date_elec) |> 
  drop_na() |> 
  select(media) |> 
  left_join(elect_surv, by = "media") |> 
  summarise(intencion = mean(intencion),
            .by = c("date_elec", "media", "siglas")) |> 
# se añade la información resumida anteriormente de los votos reales obtenidos por cada partido
  left_join(elect_surv |> 
              select(porc_votos, date_elec, siglas) |> 
              distinct(),
            by = c("date_elec", "siglas")) |> 
# los periodos en los que no se tiene porcentaje de votos registrado, se entiende que ese fue 0
  mutate(porc_votos = if_else(is.na(porc_votos), 0, porc_votos)) |> 
# se calcula la diferencia entre el porcentaje estimado y el porcentaje obtenido como estimador de la precisión de las encuestas
  mutate(diferencia = intencion - porc_votos) |> 
# se modifica el nombre de cada periodo para que quede más elegante
  mutate(periodo_electoral = fct_reorder(format(date_elec, "%b %Y"), date_elec)) |> 
# se seleccionan los partidos mayormente representativos en toda españa  
  filter(siglas %in% c("PP", "PSOE", "PODEMOS", "VOX", "CS"))
```

```{r, echo=FALSE}
# se visualiza
ggplot(medios_completos_2) + 
  geom_col(aes(y = intencion, 
               x = periodo_electoral,
               fill = siglas),
           position = position_dodge(width = 0.9),
           width = 1,
           alpha = 0.6) +
  scale_fill_manual(values = setNames(colores_partidos, c(siglas_interes, "OTROS"))) +
  facet_wrap(~media,
            scales = "free") +
  labs(title = "Diferencia media entre intención de voto estimada y \nporcentege de votos real de cada empresa de encuestas",
       fill = "Partido",
       x = "Periodo electoral",
       y = "Diferencia media")+
  theme_gg +
  theme()
```

:::

------------------------------------------------------------------------

## ¿Cómo analizar la relación entre censo y voto? ¿Es cierto que determinados partidos ganan en las zonas rurales? {.center background-image="gradiente.jpg"}

. . .

Se considera [**zona rural**]{style="color:red;"} aquella que tiene [**menos de 30.000 habitantes**]{style="color:red;"}

------------------------------------------------------------------------

```{r}
#| include: false
#Dividir municipios en 2 grupos según el censo:
rural <-
  election_tidy |> 
  filter(censo < 30000)

urbano <-
  election_tidy |> 
  filter(censo >= 30000)
```

Proporción de votos de cada partido en cada elección en [**zonas rurales**]{style="color:darkgreen;"}

```{r, echo=FALSE}
rural |> 
  summarise("votos" = sum(votos)/sum(votos_candidaturas),
            .by = c(fecha, siglas)) |> 
  left_join(colores_df, by = "siglas") |> 
  
  ggplot() +
  geom_point(aes(x = fecha, y = votos, color = color)) +
  geom_line(aes(x = fecha, y = votos, color = color, group = siglas)) +
  scale_color_identity(name = "Partidos", guide = "legend") +
  scale_y_continuous(labels = function(y) y * 100) +
  labs(x = "Elecciones",
       y = "% votos") +
  theme_gg_2

```

------------------------------------------------------------------------

Proporción de votos de cada partido en cada elección en [**zonas urbanas**]{style="color:darkblue;"}

```{r, echo=FALSE}
urbano |> 
  summarise("votos" = sum(votos)/sum(votos_candidaturas),
            .by = c(fecha, siglas)) |> 
  left_join(colores_df, by = "siglas") |> 
  
  ggplot() +
  geom_point(aes(x = fecha, y = votos, color = color)) +
  geom_line(aes(x = fecha, y = votos, color = color, group = siglas)) +
  scale_color_identity(name = "Partido", guide = "legend") +
  scale_y_continuous(labels = function(y) y * 100) +
  labs(x = "Elecciones",
       y = "% votos") +
  theme_gg_2
```
